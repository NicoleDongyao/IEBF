# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Image binaryzation.
#'
#' @param img the original image matrix
#' @param s the threshold value
#' @return the processed image matrix
bin <- function(img, s) {
    .Call(`_IEBF_bin`, img, s)
}

#' Image thinning.
#'
#' @param img the original image matrix, which is expected to represent a binary image
#' @param flag the pixel value of foreground objects, 0 for black, 1 for white
#' @return the processed image matrix
thin <- function(img, flag) {
    .Call(`_IEBF_thin`, img, flag)
}

#' Orientation field estimation.
#'
#' @param img the original image matrix
#' @param w the size of blocks into which the image is divided
#' @return the orientation of each pixel in the image matrix
field_esti <- function(img, w = 16L) {
    .Call(`_IEBF_field_esti`, img, w)
}

#' Minutiae extract.
#'
#' @param img the original image matrix
#' @return the Minutiae matrix, 1 if ridge ending & bifurcation, else 0
minutiae_set <- function(img) {
    .Call(`_IEBF_minutiae_set`, img)
}

#' Similarity score of two image matrixes.
#'
#' @param i1 image matrix 1
#' @param i2 image matrix 2
#' @param r0 the threshold value for position
#' @param theta0 the threshold value for direction
#' @return the similarity score
simi_score <- function(i1, i2, r0 = 8L, theta0 = 7L) {
    .Call(`_IEBF_simi_score`, i1, i2, r0, theta0)
}

#' The function of gabor is to create a gabor filter, which is a popular linear filter mainly used for edge detection.
#'
#' @param img a matrix that a gray-scale image turns into. The value of each element is a real between 0 and 1.
#' @param w an integer. It indicates the size of blocks that the image is divided into. The default is 16.
#' @param s an integer. It indicates the size chosen for the low-pass Gaussian filter. The default is 5.
#' @param gsize an integer. It stands for the size of gabor filter. The default is 16.
#' @param f a decimal. It indicates the ridge frequency. The default is 0.1.
#' @param vx an integer. It indicates the standard deviations of the Gaussian envelope of the first index. The default is 4.
#' @param vy an integer. It indicates the standard deviations of the Gaussian envelope of the second index. The default is 4.
#' @return a matrix. The shape of the matrix is same as that of the picture provided. Each value of the element is a real between 0 and 1.
gabor <- function(img, w = 16L, s = 5L, gsize = 16L, f = 0.1, vx = 4L, vy = 4L) {
    .Call(`_IEBF_gabor`, img, w, s, gsize, f, vx, vy)
}

#' Image The function of laplace is to create a laplace filter, which is a linear high-pass filter mainly used for edge enhancement.
#'
#' @param img a matrix that a gray-scale image turns into. The value of each element is a real between 0 and 1.
#' @param alpha a number. It is a coefficient that decides on how laplacian filter would work on the original image. The default is 1.
#' @return a matrix. The shape of the matrix is same as that of the picture provided. Each value of the element is a real between 0 and 1.
laplace <- function(img, alpha = 1) {
    .Call(`_IEBF_laplace`, img, alpha)
}

#' Compute image denoising.
#'
#' @param img the original image matrix
#' @param N the dimension of texture replacement search region
#' @param k the dimension of the texture region of the pixel to be processed
#' @param sigma the smoothing parameters
#' @return the denoised image
nlm <- function(img, N, K, sigma) {
    .Call(`_IEBF_nlm`, img, N, K, sigma)
}

#' Normalization of original pictures.
#'
#' @param img the original image matrix
#' @param m a number. It indicates the estimated mean of the image. The default is 100.
#' @param var a number. It indicates the estimated variance of the image. The default is 100.
#' @return the processed image matrix. The shape of the matrix is same as that of the picture provided. Each value of the element is a real between 0 and 1.
normal <- function(img, m = 100, var = 100) {
    .Call(`_IEBF_normal`, img, m, var)
}

#' The function of volterra is to create a Volterra filter, which is a non-linear filter whose input-output relation is a Volterra series and it represents the most natural extension of linear filters.
#'
#' @param img a matrix that a gray-scale image turns into. The value of each element is a real between 0 and 1.
#' @param c1 a number. Eq: y(n1,n2) = C1 · x2(n1,n2) − C2 · x(n1+1, n2+1) · x (n1−1, n2−1) − C3 ·x(n1+1, n2−1) · x(n1−1, n2+1) − C4 · x(n1+1, n2) · x (n1-1, n2) − C5 · x(n1, n2+1) · x(n1, n2−1) It is the first coefficient of the equation above. The default is 3.
#' @param c2 a number. It is the second coefficient of the equation above. The default is -0.5.
#' @param c3 a number. It is the third coefficient of the equation above. The default is -0.5.
#' @param c4 a number. It is the fourth coefficient of the equation above. The default is -1.
#' @param c5 a number. It is the fifth coefficient of the equation above. The default is -1.
#' @param rho A number. It is a coefficient that decides on how volterra filter would work on the original image. The default is 0.5.
#' @return a matrix. The shape of the matrix is same as that of the picture provided. Each value of the element is a real between 0 and 1.
volterra <- function(img, c1 = 3, c2 = -0.5, c3 = -0.5, c4 = -1, c5 = -1, rho = 0.5) {
    .Call(`_IEBF_volterra`, img, c1, c2, c3, c4, c5, rho)
}

